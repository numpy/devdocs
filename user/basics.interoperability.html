
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Interoperability with NumPy &#8212; NumPy v1.23.dev0 Manual</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/blank.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Miscellaneous" href="misc.html" />
    <link rel="prev" title="Copies and views" href="basics.copies.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<link rel="stylesheet" href="../_static/numpy.css" type="text/css" />

    <!-- PR #17220: This is added via javascript in versionwarning.js  -->
    <!-- link rel="canonical" href="http://numpy.org/doc/stable/user/basics.interoperability.html" / -->


  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../index.html">
  <img src="../_static/numpylogo.svg" class="logo" alt="logo">
</a>      


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../reference/index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../dev/index.html">
  Development
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://numpy.org/numpy-tutorials/">Learn<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/numpy/numpy" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/numpy_team" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="whatisnumpy.html">
   What is NumPy?
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference external" href="https://numpy.org/install/">
   Installation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="quickstart.html">
   NumPy quickstart
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="absolute_beginners.html">
   NumPy: the absolute basics for beginners
  </a>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="basics.html">
   NumPy fundamentals
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="basics.creation.html">
     Array creation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="basics.indexing.html">
     Indexing on
     <code class="xref py py-class docutils literal notranslate">
      <span class="pre">
       ndarrays
      </span>
     </code>
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="basics.io.html">
     I/O with NumPy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="basics.types.html">
     Data types
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="basics.broadcasting.html">
     Broadcasting
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="basics.byteswapping.html">
     Byte-swapping
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="basics.rec.html">
     Structured arrays
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="basics.dispatch.html">
     Writing custom array containers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="basics.subclassing.html">
     Subclassing ndarray
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="basics.ufuncs.html">
     Universal functions (
     <code class="xref py py-class docutils literal notranslate">
      <span class="pre">
       ufunc
      </span>
     </code>
     ) basics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="basics.copies.html">
     Copies and views
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Interoperability with NumPy
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="misc.html">
   Miscellaneous
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="numpy-for-matlab-users.html">
   NumPy for MATLAB users
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="building.html">
   Building from source
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="c-info.html">
   Using NumPy C-API
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference external" href="https://numpy.org/numpy-tutorials/features.html">
   NumPy Tutorials
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="howtos_index.html">
   NumPy How Tos
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="depending_on_numpy.html">
   For downstream package authors
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../f2py/index.html">
   F2PY user guide and reference manual
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../glossary.html">
   Glossary
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dev/underthehood.html">
   Under-the-hood Documentation for developers
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bugs.html">
   Reporting bugs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../release.html">
   Release notes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../license.html">
   NumPy license
  </a>
 </li>
</ul>

  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#using-arbitrary-objects-in-numpy">
   1. Using arbitrary objects in NumPy
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-array-interface-protocol">
     The array interface protocol
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-array-method">
     The
     <code class="docutils literal notranslate">
      <span class="pre">
       __array__()
      </span>
     </code>
     method
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-dlpack-protocol">
     The DLPack Protocol
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#operating-on-foreign-objects-without-converting">
   2. Operating on foreign objects without converting
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-array-ufunc-protocol">
     The
     <code class="docutils literal notranslate">
      <span class="pre">
       __array_ufunc__
      </span>
     </code>
     protocol
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-array-function-protocol">
     The
     <code class="docutils literal notranslate">
      <span class="pre">
       __array_function__
      </span>
     </code>
     protocol
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#returning-foreign-objects">
   3. Returning foreign objects
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interoperability-examples">
   Interoperability examples
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-pandas-series-objects">
     Example: Pandas
     <code class="docutils literal notranslate">
      <span class="pre">
       Series
      </span>
     </code>
     objects
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-pytorch-tensors">
     Example: PyTorch tensors
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-cupy-arrays">
     Example: CuPy arrays
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-dask-arrays">
     Example: Dask arrays
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-dlpack">
     Example: DLPack
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#further-reading">
   Further reading
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="interoperability-with-numpy">
<span id="basics-interoperability"></span><h1>Interoperability with NumPy<a class="headerlink" href="#interoperability-with-numpy" title="Permalink to this headline">¶</a></h1>
<p>NumPy’s ndarray objects provide both a high-level API for operations on
array-structured data and a concrete implementation of the API based on
<a class="reference internal" href="../reference/arrays.html#arrays"><span class="std std-ref">strided in-RAM storage</span></a>. While this API is powerful and fairly
general, its concrete implementation has limitations. As datasets grow and NumPy
becomes used in a variety of new environments and architectures, there are cases
where the strided in-RAM storage strategy is inappropriate, which has caused
different libraries to reimplement this API for their own uses. This includes
GPU arrays (<a class="reference external" href="https://cupy.dev/">CuPy</a>), Sparse arrays (<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/sparse.html#module-scipy.sparse" title="(in SciPy v1.8.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse</span></code></a>, <a class="reference external" href="https://sparse.pydata.org/">PyData/Sparse</a>)
and parallel arrays (<a class="reference external" href="https://docs.dask.org/">Dask</a> arrays) as well as various NumPy-like implementations
in deep learning frameworks, like <a class="reference external" href="https://www.tensorflow.org/">TensorFlow</a> and <a class="reference external" href="https://pytorch.org/">PyTorch</a>. Similarly, there are
many projects that build on top of the NumPy API for labeled and indexed arrays
(<a class="reference external" href="http://xarray.pydata.org/">XArray</a>), automatic differentiation (<a class="reference external" href="https://jax.readthedocs.io/">JAX</a>), masked arrays (<a class="reference internal" href="../reference/maskedarray.generic.html#module-numpy.ma" title="numpy.ma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ma</span></code></a>),
physical units (<a class="reference external" href="https://docs.astropy.org/en/stable/units/">astropy.units</a>, <a class="reference external" href="https://pint.readthedocs.io/">pint</a>, <a class="reference external" href="https://unyt.readthedocs.io/">unyt</a>), among others that add additional
functionality on top of the NumPy API.</p>
<p>Yet, users still want to work with these arrays using the familiar NumPy API and
re-use existing code with minimal (ideally zero) porting overhead. With this
goal in mind, various protocols are defined for implementations of
multi-dimensional arrays with high-level APIs matching NumPy.</p>
<p>Broadly speaking, there are three groups of features used for interoperability
with NumPy:</p>
<ol class="arabic simple">
<li><p>Methods of turning a foreign object into an ndarray;</p></li>
<li><p>Methods of deferring execution from a NumPy function to another array
library;</p></li>
<li><p>Methods that use NumPy functions and return an instance of a foreign object.</p></li>
</ol>
<p>We describe these features below.</p>
<section id="using-arbitrary-objects-in-numpy">
<h2>1. Using arbitrary objects in NumPy<a class="headerlink" href="#using-arbitrary-objects-in-numpy" title="Permalink to this headline">¶</a></h2>
<p>The first set of interoperability features from the NumPy API allows foreign
objects to be treated as NumPy arrays whenever possible. When NumPy functions
encounter a foreign object, they will try (in order):</p>
<ol class="arabic simple">
<li><p>The buffer protocol, described <a class="reference external" href="https://docs.python.org/3/c-api/buffer.html" title="(in Python v3.10)"><span class="xref std std-doc">in the Python C-API documentation</span></a>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">__array_interface__</span></code> protocol, described
<a class="reference internal" href="../reference/arrays.interface.html#arrays-interface"><span class="std std-ref">in this page</span></a>. A precursor to Python’s buffer
protocol, it defines a way to access the contents of a NumPy array from other
C extensions.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">__array__()</span></code> method, which asks an arbitrary object to convert
itself into an array.</p></li>
</ol>
<p>For both the buffer and the <code class="docutils literal notranslate"><span class="pre">__array_interface__</span></code> protocols, the object
describes its memory layout and NumPy does everything else (zero-copy if
possible). If that’s not possible, the object itself is responsible for
returning a <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> from <code class="docutils literal notranslate"><span class="pre">__array__()</span></code>.</p>
<p><a class="reference external" href="https://dmlc.github.io/dlpack/latest/index.html" title="(in DLPack)"><span class="xref std std-doc">DLPack</span></a> is yet another protocol to convert foreign objects
to NumPy arrays in a language and device agnostic manner. NumPy doesn’t implicitly
convert objects to ndarrays using DLPack. It provides the function
<a class="reference internal" href="../reference/generated/numpy.from_dlpack.html#numpy.from_dlpack" title="numpy.from_dlpack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.from_dlpack</span></code></a> that accepts any object implementing the <code class="docutils literal notranslate"><span class="pre">__dlpack__</span></code> method
and outputs a NumPy ndarray (which is generally a view of the input object’s data
buffer). The <a class="reference external" href="https://dmlc.github.io/dlpack/latest/python_spec.html#python-spec" title="(in DLPack)"><span>Python Specification for DLPack</span></a> page explains the <code class="docutils literal notranslate"><span class="pre">__dlpack__</span></code> protocol
in detail.</p>
<section id="the-array-interface-protocol">
<h3>The array interface protocol<a class="headerlink" href="#the-array-interface-protocol" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../reference/arrays.interface.html#arrays-interface"><span class="std std-ref">array interface protocol</span></a> defines a way for
array-like objects to re-use each other’s data buffers. Its implementation
relies on the existence of the following attributes or methods:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__array_interface__</span></code>: a Python dictionary containing the shape, the
element type, and optionally, the data buffer address and the strides of an
array-like object;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__array__()</span></code>: a method returning the NumPy ndarray view of an array-like
object;</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">__array_interface__</span></code> attribute can be inspected directly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">__array_interface__</span>
<span class="go">{&#39;data&#39;: (94708397920832, False), &#39;strides&#39;: None, &#39;descr&#39;: [(&#39;&#39;, &#39;&lt;f8&#39;)], &#39;typestr&#39;: &#39;&lt;f8&#39;, &#39;shape&#39;: (4,), &#39;version&#39;: 3}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">__array_interface__</span></code> attribute can also be used to manipulate the object
data in place:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">wrapper</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">__array_interface__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span>
<span class="go">{&#39;data&#39;: (140497590272032, False), &#39;strides&#39;: None, &#39;descr&#39;: [(&#39;&#39;, &#39;&lt;i8&#39;)], &#39;typestr&#39;: &#39;&lt;i8&#39;, &#39;shape&#39;: (4,), &#39;version&#39;: 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">wrapper</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="o">.</span><span class="n">__array_interface__</span> <span class="o">=</span> <span class="n">buf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_arr</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>We can check that <code class="docutils literal notranslate"><span class="pre">arr</span></code> and <code class="docutils literal notranslate"><span class="pre">new_arr</span></code> share the same data buffer:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_arr</span>
<span class="go">array([[1000,    2],</span>
<span class="go">       [   3,    4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span>
<span class="go">array([1000, 2, 3, 4])</span>
</pre></div>
</div>
</section>
<section id="the-array-method">
<h3>The <code class="docutils literal notranslate"><span class="pre">__array__()</span></code> method<a class="headerlink" href="#the-array-method" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__array__()</span></code> method ensures that any NumPy-like object (an array, any
object exposing the array interface, an object whose <code class="docutils literal notranslate"><span class="pre">__array__()</span></code> method
returns an array or any nested sequence) that implements it can be used as a
NumPy array. If possible, this will mean using <code class="docutils literal notranslate"><span class="pre">__array__()</span></code> to create a NumPy
ndarray view of the array-like object. Otherwise, this copies the data into a
new ndarray object. This is not optimal, as coercing arrays into ndarrays may
cause performance problems or create the need for copies and loss of metadata,
as the original object and any attributes/behavior it may have had, is lost.</p>
<p>To see an example of a custom array implementation including the use of
<code class="docutils literal notranslate"><span class="pre">__array__()</span></code>, see <a class="reference internal" href="basics.dispatch.html#basics-dispatch"><span class="std std-ref">Writing custom array containers</span></a>.</p>
</section>
<section id="the-dlpack-protocol">
<h3>The DLPack Protocol<a class="headerlink" href="#the-dlpack-protocol" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://dmlc.github.io/dlpack/latest/index.html" title="(in DLPack)"><span class="xref std std-doc">DLPack</span></a> protocol defines a memory-layout of
strided n-dimensional array objects. It offers the following syntax
for data exchange:</p>
<ol class="arabic simple">
<li><p>A <a class="reference internal" href="../reference/generated/numpy.from_dlpack.html#numpy.from_dlpack" title="numpy.from_dlpack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.from_dlpack</span></code></a> function, which accepts (array) objects with a
<code class="docutils literal notranslate"><span class="pre">__dlpack__</span></code> method and uses that method to construct a new array
containing the data from <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__dlpack__(self,</span> <span class="pre">stream=None)</span></code> and <code class="docutils literal notranslate"><span class="pre">__dlpack_device__</span></code> methods on the
array object, which will be called from within <code class="docutils literal notranslate"><span class="pre">from_dlpack</span></code>, to query
what device the array is on (may be needed to pass in the correct
stream, e.g. in the case of multiple GPUs) and to access the data.</p></li>
</ol>
<p>Unlike the buffer protocol, DLPack allows exchanging arrays containing data on
devices other than the CPU (e.g. Vulkan or GPU). Since NumPy only supports CPU,
it can only convert objects whose data exists on the CPU. But other libraries,
like <a class="reference external" href="https://pytorch.org/">PyTorch</a> and <a class="reference external" href="https://cupy.dev/">CuPy</a>, may exchange data on GPU using this protocol.</p>
</section>
</section>
<section id="operating-on-foreign-objects-without-converting">
<h2>2. Operating on foreign objects without converting<a class="headerlink" href="#operating-on-foreign-objects-without-converting" title="Permalink to this headline">¶</a></h2>
<p>A second set of methods defined by the NumPy API allows us to defer the
execution from a NumPy function to another array library.</p>
<p>Consider the following function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="../reference/generated/numpy.exp.html#numpy.exp" title="numpy.exp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.exp</span></code></a> is a <a class="reference internal" href="basics.ufuncs.html#ufuncs-basics"><span class="std std-ref">ufunc</span></a>, which means
that it operates on ndarrays in an element-by-element fashion. On the other
hand, <a class="reference internal" href="../reference/generated/numpy.mean.html#numpy.mean" title="numpy.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.mean</span></code></a> operates along one of the array’s axes.</p>
<p>We can apply <code class="docutils literal notranslate"><span class="pre">f</span></code> to a NumPy ndarray object directly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">21.1977562209304</span>
</pre></div>
</div>
<p>We would like this function to work equally well with any NumPy-like array
object.</p>
<p>NumPy allows a class to indicate that it would like to handle computations in a
custom-defined way through the following interfaces:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code>: allows third-party objects to support and override
<a class="reference internal" href="basics.ufuncs.html#ufuncs-basics"><span class="std std-ref">ufuncs</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__array_function__</span></code>: a catch-all for NumPy functionality that is not
covered by the <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> protocol for universal functions.</p></li>
</ul>
<p>As long as foreign objects implement the <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> or
<code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocols, it is possible to operate on them without the
need for explicit conversion.</p>
<section id="the-array-ufunc-protocol">
<h3>The <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> protocol<a class="headerlink" href="#the-array-ufunc-protocol" title="Permalink to this headline">¶</a></h3>
<p>A <a class="reference internal" href="basics.ufuncs.html#ufuncs-basics"><span class="std std-ref">universal function (or ufunc for short)</span></a> is a
“vectorized” wrapper for a function that takes a fixed number of specific inputs
and produces a fixed number of specific outputs. The output of the ufunc (and
its methods) is not necessarily a ndarray, if not all input arguments are
ndarrays. Indeed, if any input defines an <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> method, control
will be passed completely to that function, i.e., the ufunc is overridden. The
<code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> method defined on that (non-ndarray) object has access to
the NumPy ufunc. Because ufuncs have a well-defined structure, the foreign
<code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> method may rely on ufunc attributes like <code class="docutils literal notranslate"><span class="pre">.at()</span></code>,
<code class="docutils literal notranslate"><span class="pre">.reduce()</span></code>, and others.</p>
<p>A subclass can override what happens when executing NumPy ufuncs on it by
overriding the default <code class="docutils literal notranslate"><span class="pre">ndarray.__array_ufunc__</span></code> method. This method is
executed instead of the ufunc and should return either the result of the
operation, or <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> if the operation requested is not implemented.</p>
</section>
<section id="the-array-function-protocol">
<h3>The <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol<a class="headerlink" href="#the-array-function-protocol" title="Permalink to this headline">¶</a></h3>
<p>To achieve enough coverage of the NumPy API to support downstream projects,
there is a need to go beyond <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> and implement a protocol that
allows arguments of a NumPy function to take control and divert execution to
another function (for example, a GPU or parallel implementation) in a way that
is safe and consistent across projects.</p>
<p>The semantics of <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> are very similar to <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code>,
except the operation is specified by an arbitrary callable object rather than a
ufunc instance and method. For more details, see <a class="reference external" href="https://numpy.org/neps/nep-0018-array-function-protocol.html#nep18" title="(in NumPy Enhancement Proposals)"><span>NEP 18 — A dispatch mechanism for NumPy’s high level array functions</span></a>.</p>
</section>
</section>
<section id="returning-foreign-objects">
<h2>3. Returning foreign objects<a class="headerlink" href="#returning-foreign-objects" title="Permalink to this headline">¶</a></h2>
<p>A third type of feature set is meant to use the NumPy function implementation
and then convert the return value back into an instance of the foreign object.
The <code class="docutils literal notranslate"><span class="pre">__array_finalize__</span></code> and <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> methods act behind the scenes
to ensure that the return type of a NumPy function can be specified as needed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__array_finalize__</span></code> method is the mechanism that NumPy provides to allow
subclasses to handle the various ways that new instances get created. This
method is called whenever the system internally allocates a new array from an
object which is a subclass (subtype) of the ndarray. It can be used to change
attributes after construction, or to update meta-information from the “parent.”</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> method “wraps up the action” in the sense of allowing any
object (such as user-defined functions) to set the type of its return value and
update attributes and metadata. This can be seen as the opposite of the
<code class="docutils literal notranslate"><span class="pre">__array__</span></code> method. At the end of every object that implements
<code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code>, this method is called on the input object with the highest
<em>array priority</em>, or the output object if one was specified. The
<code class="docutils literal notranslate"><span class="pre">__array_priority__</span></code> attribute is used to determine what type of object to
return in situations where there is more than one possibility for the Python
type of the returned object. For example, subclasses may opt to use this method
to transform the output array into an instance of the subclass and update
metadata before returning the array to the user.</p>
<p>For more information on these methods, see <a class="reference internal" href="basics.subclassing.html#basics-subclassing"><span class="std std-ref">Subclassing ndarray</span></a> and
<a class="reference internal" href="c-info.beyond-basics.html#specific-array-subtyping"><span class="std std-ref">Specific features of ndarray sub-typing</span></a>.</p>
</section>
<section id="interoperability-examples">
<h2>Interoperability examples<a class="headerlink" href="#interoperability-examples" title="Permalink to this headline">¶</a></h2>
<section id="example-pandas-series-objects">
<h3>Example: Pandas <code class="docutils literal notranslate"><span class="pre">Series</span></code> objects<a class="headerlink" href="#example-pandas-series-objects" title="Permalink to this headline">¶</a></h3>
<p>Consider the following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">ser</span><span class="p">)</span>
<span class="go">pandas.core.series.Series</span>
</pre></div>
</div>
<p>Now, <code class="docutils literal notranslate"><span class="pre">ser</span></code> is <strong>not</strong> a ndarray, but because it
<a class="reference external" href="https://pandas.pydata.org/docs/user_guide/dsintro.html#dataframe-interoperability-with-numpy-functions">implements the __array_ufunc__ protocol</a>,
we can apply ufuncs to it as if it were a ndarray:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ser</span><span class="p">)</span>
<span class="go">   0     2.718282</span>
<span class="go">   1     7.389056</span>
<span class="go">   2    20.085537</span>
<span class="go">   3    54.598150</span>
<span class="go">   dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ser</span><span class="p">)</span>
<span class="go">   0    0.841471</span>
<span class="go">   1    0.909297</span>
<span class="go">   2    0.141120</span>
<span class="go">   3   -0.756802</span>
<span class="go">   dtype: float64</span>
</pre></div>
</div>
<p>We can even do operations with other ndarrays:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ser</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]))</span>
<span class="go">   0     6</span>
<span class="go">   1     8</span>
<span class="go">   2    10</span>
<span class="go">   3    12</span>
<span class="go">   dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">ser</span><span class="p">)</span>
<span class="go">21.1977562209304</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">ser</span><span class="o">.</span><span class="n">__array__</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">numpy.ndarray</span>
</pre></div>
</div>
</section>
<section id="example-pytorch-tensors">
<h3>Example: PyTorch tensors<a class="headerlink" href="#example-pytorch-tensors" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://pytorch.org/">PyTorch</a> is an optimized tensor library for deep
learning using GPUs and CPUs. PyTorch arrays are commonly called <em>tensors</em>.
Tensors are similar to NumPy’s ndarrays, except that tensors can run on GPUs or
other hardware accelerators. In fact, tensors and NumPy arrays can often share
the same underlying memory, eliminating the need to copy data.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">x_np</span></code> and <code class="docutils literal notranslate"><span class="pre">x_tensor</span></code> are different kinds of objects:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_np</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_tensor</span>
<span class="go">tensor([[1, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
<p>However, we can treat PyTorch tensors as NumPy arrays without the need for
explicit conversion:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x_tensor</span><span class="p">)</span>
<span class="go">tensor([[ 2.7183,  7.3891],</span>
<span class="go">        [20.0855, 54.5982]], dtype=torch.float64)</span>
</pre></div>
</div>
<p>Also, note that the return type of this function is compatible with the initial
data type.</p>
<div class="admonition-warning admonition">
<p class="admonition-title">Warning</p>
<p>While this mixing of ndarrays and tensors may be convenient, it is not
recommended. It will not work for non-CPU tensors, and will have unexpected
behavior in corner cases. Users should prefer explicitly converting the
ndarray to a tensor.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PyTorch does not implement <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> or <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code>.
Under the hood, the <code class="docutils literal notranslate"><span class="pre">Tensor.__array__()</span></code> method returns a NumPy ndarray as
a view of the tensor data buffer. See <a class="reference external" href="https://github.com/pytorch/pytorch/issues/24015">this issue</a> and the
<a class="reference external" href="https://github.com/pytorch/pytorch/blob/master/torch/overrides.py">__torch_function__ implementation</a>
for details.</p>
</div>
<p>Note also that we can see <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> in action here, even though
<code class="docutils literal notranslate"><span class="pre">torch.Tensor</span></code> is not a subclass of ndarray:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">tensor([0, 1, 2, 3])</span>
</pre></div>
</div>
<p>PyTorch implements <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> to be able to get tensors back from NumPy
functions, and we can modify it directly to control which type of objects are
returned from these functions.</p>
</section>
<section id="example-cupy-arrays">
<h3>Example: CuPy arrays<a class="headerlink" href="#example-cupy-arrays" title="Permalink to this headline">¶</a></h3>
<p>CuPy is a NumPy/SciPy-compatible array library for GPU-accelerated computing
with Python. CuPy implements a subset of the NumPy interface by implementing
<code class="docutils literal notranslate"><span class="pre">cupy.ndarray</span></code>, <a class="reference external" href="https://docs.cupy.dev/en/stable/reference/ndarray.html">a counterpart to NumPy ndarrays</a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">cupy.ndarray</span></code> object implements the <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> interface. This
enables NumPy ufuncs to be applied to CuPy arrays (this will defer operation to
the matching CuPy CUDA/ROCm implementation of the ufunc):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x_gpu</span><span class="p">))</span>
<span class="go">array(21.19775622)</span>
</pre></div>
</div>
<p>Note that the return type of these operations is still consistent with the
initial type:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
<span class="go">&lt;class &#39;cupy._core.core.ndarray&#39;&gt;</span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://docs.cupy.dev/en/stable/reference/ufunc.html">this page in the CuPy documentation for details</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">cupy.ndarray</span></code> also implements the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> interface, meaning
it is possible to do operations such as</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qr_gpu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a_gpu</span><span class="p">)</span>
</pre></div>
</div>
<p>CuPy implements many NumPy functions on <code class="docutils literal notranslate"><span class="pre">cupy.ndarray</span></code> objects, but not all.
See <a class="reference external" href="https://docs.cupy.dev/en/stable/user_guide/difference.html">the CuPy documentation</a>
for details.</p>
</section>
<section id="example-dask-arrays">
<h3>Example: Dask arrays<a class="headerlink" href="#example-dask-arrays" title="Permalink to this headline">¶</a></h3>
<p>Dask is a flexible library for parallel computing in Python. Dask Array
implements a subset of the NumPy ndarray interface using blocked algorithms,
cutting up the large array into many small arrays. This allows computations on
larger-than-memory arrays using multiple cores.</p>
<p>Dask supports <code class="docutils literal notranslate"><span class="pre">__array__()</span></code> and <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">dask.array&lt;mean_agg-aggregate, shape=(), dtype=float64, chunksize=(), chunktype=numpy.ndarray&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="go">5.090097550553843</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Dask is lazily evaluated, and the result from a computation isn’t computed
until you ask for it by invoking <code class="docutils literal notranslate"><span class="pre">compute()</span></code>.</p>
</div>
<p>See <a class="reference external" href="https://docs.dask.org/en/stable/array.html">the Dask array documentation</a>
and the <a class="reference external" href="https://docs.dask.org/en/stable/array.html#scope">scope of Dask arrays interoperability with NumPy arrays</a> for details.</p>
</section>
<section id="example-dlpack">
<h3>Example: DLPack<a class="headerlink" href="#example-dlpack" title="Permalink to this headline">¶</a></h3>
<p>Several Python data science libraries implement the <code class="docutils literal notranslate"><span class="pre">__dlpack__</span></code> protocol.
Among them are <a class="reference external" href="https://pytorch.org/">PyTorch</a> and <a class="reference external" href="https://cupy.dev/">CuPy</a>. A full list of libraries that implement
this protocol can be found on
<a class="reference external" href="https://dmlc.github.io/dlpack/latest/index.html" title="(in DLPack)"><span class="xref std std-doc">this page of DLPack documentation</span></a>.</p>
<p>Convert a PyTorch CPU tensor to NumPy array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_torch</span>
<span class="go">tensor([0, 1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">from_dlpack</span><span class="p">(</span><span class="n">x_torch</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_np</span>
<span class="go">array([0, 1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># note that x_np is a view of x_torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_torch</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_torch</span>
<span class="go">tensor([  0, 100,   2,   3,   4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_np</span>
<span class="go">array([  0, 100,   2,   3,   4])</span>
</pre></div>
</div>
<p>The imported arrays are read-only so writing or operating in-place will fail:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_np</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">assignment destination is read-only</span>
</pre></div>
</div>
<p>A copy must be created in order to operate on the imported arrays in-place, but
will mean duplicating the memory. Do not do this for very large arrays:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_np_copy</span> <span class="o">=</span> <span class="n">x_np</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_np_copy</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># works</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that GPU tensors can’t be converted to NumPy arrays since NumPy doesn’t
support GPU devices:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">from_dlpack</span><span class="p">(</span><span class="n">x_torch</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">Unsupported device in DLTensor.</span>
</pre></div>
</div>
<p>But, if both libraries support the device the data buffer is on, it is
possible to use the <code class="docutils literal notranslate"><span class="pre">__dlpack__</span></code> protocol (e.g. <a class="reference external" href="https://pytorch.org/">PyTorch</a> and <a class="reference external" href="https://cupy.dev/">CuPy</a>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_cupy</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">from_dlpack</span><span class="p">(</span><span class="n">x_torch</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Similarly, a NumPy array can be converted to a PyTorch tensor:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_dlpack</span><span class="p">(</span><span class="n">x_np</span><span class="p">)</span>
</pre></div>
</div>
<p>Read-only arrays cannot be exported:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_np</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">from_dlpack</span><span class="p">(</span><span class="n">x_np</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;.../site-packages/torch/utils/dlpack.py&quot;</span>, line <span class="m">63</span>, in <span class="n">from_dlpack</span>
    <span class="n">dlpack</span> <span class="o">=</span> <span class="n">ext_tensor</span><span class="o">.</span><span class="n">__dlpack__</span><span class="p">()</span>
<span class="gr">TypeError</span>: <span class="n">NumPy currently only supports dlpack for writeable arrays</span>
</pre></div>
</div>
</section>
</section>
<section id="further-reading">
<h2>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="../reference/arrays.interface.html#arrays-interface"><span class="std std-ref">The array interface protocol</span></a></p></li>
<li><p><a class="reference internal" href="basics.dispatch.html#basics-dispatch"><span class="std std-ref">Writing custom array containers</span></a></p></li>
<li><p><a class="reference internal" href="../reference/arrays.classes.html#special-attributes-and-methods"><span class="std std-ref">Special attributes and methods</span></a> (details on the <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> and
<code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocols)</p></li>
<li><p><a class="reference internal" href="basics.subclassing.html#basics-subclassing"><span class="std std-ref">Subclassing ndarray</span></a> (details on the <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> and
<code class="docutils literal notranslate"><span class="pre">__array_finalize__</span></code> methods)</p></li>
<li><p><a class="reference internal" href="c-info.beyond-basics.html#specific-array-subtyping"><span class="std std-ref">Specific features of ndarray sub-typing</span></a> (more details on the implementation of
<code class="docutils literal notranslate"><span class="pre">__array_finalize__</span></code>, <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> and <code class="docutils literal notranslate"><span class="pre">__array_priority__</span></code>)</p></li>
<li><p><a class="reference external" href="https://numpy.org/neps/roadmap.html" title="(in NumPy Enhancement Proposals)"><span class="xref std std-doc">NumPy roadmap: interoperability</span></a></p></li>
<li><p><a class="reference external" href="https://pytorch.org/tutorials/beginner/blitz/tensor_tutorial.html#bridge-to-np-label">PyTorch documentation on the Bridge with NumPy</a></p></li>
</ul>
</section>
</section>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="basics.copies.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Copies and views</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="misc.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Miscellaneous</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2008-2022, NumPy Developers.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.2.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>